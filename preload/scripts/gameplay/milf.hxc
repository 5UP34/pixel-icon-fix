import flixel.FlxSprite;
import flixel.FlxG;
import flixel.util.FlxTimer;
import funkin.Conductor;
import funkin.Paths;
import funkin.modding.events.ScriptEvent.UpdateScriptEvent;
import funkin.modding.module.Module;
import funkin.play.PlayState;

/**
 * TODO: After redoing the chart format, add a ScriptedSong class,
 * make this extend that, and have the constructor call `super('milf')`.
 */
class MILFGameplayModule extends Module
{
	public function new()
	{
		super('vanilla-gameplay-milf');
	}

	/**
	 * Health lost when hit by lamp.
	 */
	var HEALTH_LOSS = 0.25 * 2;

	/**
	 * How many henchmen there are.
	 * We could just hard-code this, but making it a variable improves readability.
	 */
	var HENCHMEN_COUNT = 5;

	/**
	 * How many milliseconds to wait until resetting the lamp for the next hit.
	 */
	var LAMP_RESET_DELAY = 1000 * 3;

	/**
	 * The lamp will move this many pixels per millisecond towards Boyfriend/Henchmen.
	 */
	var LAMP_VELOCITY = 5.0;

	/**
	 * Increase this number to make the henchman die later.
	 */
	var HENCHMAN_COLLISION_OFFSET = 300;

	/*
	 * The millisecond times at which the lamp passes by.
	 */
	var BOYFRIEND_LAMP_TIMES = [
		500, // Beginning of the song for testing.
		87900 // The duet down note.
	];
	var HENCHMEN_LAMP_TIMES = [
		1000,
		87900
	];

	/**
	 * Returns true if we are in a level we should use the lamp on.
	 */
	public function isCorrectSong()
	{
		// Don't run the script if we aren't in a song.
		if (PlayState.currentSong == null)
			return false;

		// Don't run the script if we aren't on Hard difficulty.
		if (PlayState.storyDifficulty != 2)
			return false;

		// Don't run the script if we aren't on the song MILF
		if (PlayState.currentSong.song.toLowerCase() != "milf")
			return false;

		return true;
	}

	/**
	 * Returns true if the player is currently holding a down note to avoid the lamp.
	 */
	public function isPlayerDucking()
	{
		// Right now we just assume if they're holding down at the right time, it counts.
		return PlayState.instance.controls.NOTE_DOWN;
	}

	var nextBFLampIndex = 0;
	var nextHenchLampIndex = 0;

	var hasCurrentBFLampHit = false;
	var currentHenchmenIndex = 1;

	function createGib(type:Int):FlxSprite {
		var gibSprite:FlxSprite = new FlxSprite();
		gibSprite.antialiasing = true;
		gibSprite.angle = FlxG.random.int(0, 360);
		gibSprite.active = true;
		gibSprite.velocity.x = FlxG.random.int(-20, -1000);
		// gibSprite.velocity.x = FlxG.random.int(-400, -850);
		gibSprite.velocity.y = FlxG.random.int(-20, -260);
		gibSprite.maxVelocity.x = gibSprite.maxVelocity.y = 0; // no cap on velocity...
		gibSprite.acceleration.y = FlxG.random.int(400, 1400); // Gravity, baby!
		gibSprite.acceleration.x = 8000; // Wind, baby!
		gibSprite.frames = frames = Paths.getSparrowAtlas('limo/henchmen');

		var random:Bool = FlxG.random.bool();
		var animationName = "";
		switch(type) {
			case 0:
				animationName = "hench head spin " + (random ? "1" : "2");
			case 1:
				animationName = "hench arm spin " + (random ? "1" : "2");
			case 2:
				animationName = "hench leg spin " + (random ? "1" : "2");
			default:
				trace('BAD TYPE '+type);
		}

		gibSprite.animation.addByPrefix(animationName, animationName, FlxG.random.int(15, 45), true);
		gibSprite.animation.play(animationName);

		return gibSprite;
	}

	function gibHenchman(target:FlxSprite) {
		var headGib = createGib(0);
		headGib.x = target.getGraphicMidpoint().x + FlxG.random.int(-20, 20);
		headGib.y = target.getGraphicMidpoint().y - 150;
		headGib.zIndex = target.zIndex;
		PlayState.instance.currentStage.add(headGib);
		
		var armGib = createGib(1);
		armGib.x = target.getGraphicMidpoint().x + FlxG.random.int(-20, 20);
		armGib.y = target.getGraphicMidpoint().y - 100;
		armGib.zIndex = target.zIndex;
		PlayState.instance.currentStage.add(armGib);

		var legGib = createGib(2);
		legGib.x = target.getGraphicMidpoint().x + FlxG.random.int(-20, 20);
		legGib.y = target.getGraphicMidpoint().y;
		legGib.zIndex = target.zIndex;
		PlayState.instance.currentStage.add(legGib);

		// Refresh the stage to reorganize props by z-index.
		PlayState.instance.currentStage.refresh();

		// Cleanup after a few seconds.
		var timer = new FlxTimer();
		timer.start(5, function() {
			PlayState.instance.currentStage.remove(headGib);
			PlayState.instance.currentStage.remove(armGib);
			PlayState.instance.currentStage.remove(legGib);
		});
	}

	public function onUpdate(event:UpdateScriptEvent)
	{
		super.onUpdate(event);

		if (PlayState.instance == null || PlayState.instance.currentStage == null)
			return;

		if (!isCorrectSong())
			return;

		if (nextBFLampIndex < BOYFRIEND_LAMP_TIMES.length) {
			if (Conductor.songPosition >= BOYFRIEND_LAMP_TIMES[nextBFLampIndex] && !hasCurrentBFLampHit) {
				// Do the actual lamp collision animation and gameplay.
				doLampHit();
				hasCurrentBFLampHit = true;
			}
			
			if (Conductor.songPosition >= (BOYFRIEND_LAMP_TIMES[nextBFLampIndex] + LAMP_RESET_DELAY)) {
				nextBFLampIndex++;
				hasCurrentBFLampHit = false;
			}
			// Move the lamp across the screen
			var lamp = PlayState.instance.currentStage.getNamedProp('boyfriendLight');
			var boyfriend = PlayState.instance.currentStage.getBoyfriend();
			var boyfriendXPos = boyfriend.x;
			var lampDelay = BOYFRIEND_LAMP_TIMES[nextBFLampIndex] - Conductor.songPosition;
			var lampDistance = lampDelay * LAMP_VELOCITY;
			lamp.x = boyfriendXPos - lampDistance;
		} else {
			// Stop doing lamp logic after the last lamp passes.
		}

		if (nextHenchLampIndex < HENCHMEN_LAMP_TIMES.length) {
			// The time when the next lamp hits.
			var nextHenchLampTime = HENCHMEN_LAMP_TIMES[nextHenchLampIndex];
			var nextHenchLampReset = nextHenchLampTime + LAMP_RESET_DELAY;
			if (Conductor.songPosition >= nextHenchLampReset) {
				currentHenchmenIndex = 1;

				for (i in 1...(HENCHMEN_COUNT + 1)) {
					var henchman = PlayState.instance.currentStage.getNamedProp('limoDancer' + i);
					henchman.visible = true;
					henchman.animOffsets = [0, 0];
					henchman.resetPosition();
					henchman.playAnimation('danceLeft', true);
				}
				nextHenchLampIndex++;
			} else {
				// Move the lamp across the screen
				var lamp = PlayState.instance.currentStage.getNamedProp('henchmenLight');
				var HENCHMAN_BASE_X_POS = 0;
				var lampDelay = nextHenchLampTime - Conductor.songPosition;
				var lampDistance = lampDelay * LAMP_VELOCITY;
				lamp.x = HENCHMAN_BASE_X_POS - lampDistance;

				// Move hit henchmen with the lamp.
				for (i in 1...(currentHenchmenIndex + 1 - 1)) {
					var henchmen = PlayState.instance.currentStage.getNamedProp('limoDancer' + i);
					if (henchmen.visible) {
						henchmen.x = lamp.x + henchmen.animOffsets[0];
					}
				}

				// Gib the henchmen if they're in the lamp.
				if (currentHenchmenIndex <= HENCHMEN_COUNT) {
					var henchman = PlayState.instance.currentStage.getNamedProp('limoDancer' + currentHenchmenIndex);
					var henchmanCenterX = henchman.x + (henchman.width / 2) + HENCHMAN_COLLISION_OFFSET;
					var lampCenterX = lamp.x + (lamp.width / 2);
					if (lampCenterX >= henchmanCenterX) {
						// Lamp has reached the henchman.
						trace('Hit henchmen sprite ' + currentHenchmenIndex);
						
						// TODO: True knocks the henchman back, false explodes them into gibs.
						// Make the result random once both are implemented and look how we want them.
						if (FlxG.random.bool()) {
							// Move henchman along with lamp.
							
							if (FlxG.random.bool()) {
								trace('FLING1');
							  	henchman.forceAnimationForDuration('hit1', 2.0);
							} else {
								trace('FLING2');
								henchman.forceAnimationForDuration('hit2', 2.0);
							}
						} else {
							trace('EXPLODE');
							// Explode henchman into gibs.
							gibHenchman(henchman);
							henchman.visible = false;
						}

						// Play the gib sound if this is the first henchman.
						if (currentHenchmenIndex == 1) {
							FlxG.sound.play(Paths.sound('Henchmen_Wipe'), 1.0);
						}
						currentHenchmenIndex++;
					}
				}
			}
		} else {
			// Stop doing lamp logic after the last lamp passes.
		}
	}

	/**
	 * Check whether the player hit or dodged the lamp, and play the appropriate sound.
	 * Also plays an animation and lowers the player's health.
	 */
	public function doLampHit()
	{
		trace("LAMP TIME!");

		if (isPlayerDucking())
		{
			trace("Player dodged!");
			FlxG.sound.play(Paths.soundRandom('Light_Pass_Head_', 1, 4), 1.0);

			trace(PlayState.instance.currentStage.getBoyfriend().animation.getNameList());
			PlayState.instance.currentStage.getBoyfriend().playAnimation('dodge', true, true);
		}
		else
		{
			trace("Player hit!");
			FlxG.sound.play(Paths.sound('BF_Hit_by_Passing_Light'), 1.0);

			// Lose health when hit.
			PlayState.instance.health -= HEALTH_LOSS;

			// White flash on screen.
			FlxG.camera.fade(0xFFFFFFFF, 0.6, true);

			// Play the miss animation.
			PlayState.instance.currentStage.getBoyfriend().playAnimation('hit', true, true);
		}
	}

	function hardResetSong() {
			trace('Resetting lamps');
			hasCurrentBFLampHit = false;
			nextBFLampIndex = 0;
			nextHenchLampIndex = 0;
			currentHenchmenIndex = 1;

			for (i in 1...(HENCHMEN_COUNT + 1)) {
				var henchman = PlayState.instance.currentStage.getNamedProp('limoDancer' + i);
				henchman.visible = true;
				henchman.animOffsets = [0, 0];
				henchman.resetPosition();
				henchman.playAnimation('danceLeft', true);
			}
	}

	/**
	 * Make sure the lamp is properly instantiated when the song starts.
	 */
	override function onCreate(event:ScriptEvent):Void
	{
		super.onCreate(event);

		// Properly reset lights and collision when starting the song.
		if (isCorrectSong())
		{
			hardResetSong();
		}
	}

	/**
	 * Make sure the lamp is reset when the song restarts.
	 */
	override function onSongRetry(event:ScriptEvent)
	{
		super.onSongRetry(event);

		// Properly reset lights and collision when restarting the song.
		if (isCorrectSong())
		{
			hardResetSong();
		}
	}
}
