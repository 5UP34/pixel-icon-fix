import flixel.FlxG;
import flixel.FlxSprite;
import funkin.Conductor;
import funkin.Paths;
import funkin.util.BezierUtil;

// We have to use FlxBasePoint in scripts because FlxPoint is inlined and not available in scripts
import flixel.math.FlxBasePoint;

/**
 * A sprite which represents a spraycan flying through the air that Pico must shoot.
 */
class SpraycanSprite extends FlxSprite
{
	/**
	 * The position of the can when it is in the pile ready to be thrown.
	 */
	public var initialPosition:FlxPoint;

	/**
	 * The position on screen that the spray can should start arcing at.
	 */
	public var arcStartingPosition:FlxPoint;
	/**
	 * The Conductor time at which the spray can should reach the ending position.
	 */
	 public var startingTime:Float;
	/**
	 * The position on screen that the spray can should finish arcing at.
	 */
	public var arcEndingPosition:FlxPoint;
	/**
	 * The Conductor time at which the spray can should reach the ending position.
	 */
	public var endingTime:Float;

	public var STATE_IDLE:Int = 0;
	public var STATE_KICKED:Int = 1;
	public var STATE_ARCING:Int = 2;
	public var STATE_SHOT:Int = 3;
	public var STATE_IMPACTED:Int = 4;

	public var currentState:Int = 0;

	function new()
	{
		super(0, 0);

		zIndex = 1900;

		frames = Paths.getSparrowAtlas('Spraypaint_Can_Assets');
		antialiasing = true;

		// Stationary can
		animation.addByPrefix('idle', 'singular can', 24, true);
		// Can kicked upward, with smear
		animation.addByPrefix('kick', 'can kicked up', 24, true);
		// Can with lit fuse
		animation.addByPrefix('fire', 'can on fire', 24, true);
		// Can bouncing off Pico before exploding
		animation.addByPrefix('bounce', 'can bounce off head', 24, false);
		// Can that has been shot
		animation.addByPrefix('shot', 'can shot bend', 24, false);
	}

	function setArcProperties(startPos:FlxBasePoint, startTime:Float, endPos:FlxBasePoint, endTime:Float)
	{
		arcStartingPosition = startPos;
		startingTime = startTime;
		arcEndingPosition = endPos;
		endingTime = endTime;

		var xDiff = endPos.x - startPos.x;

		trace('Duration: ' + (endTime - startTime));
	}

	function playOptional(name:String) {
		if (animation.curAnim == null || animation.curAnim.name != name) {
			trace("Playing can animation: " + name);
			animation.play(name);
		}
	}

	function update(elapsed:Float) {
		super.update(elapsed);

		switch(currentState) {
			case STATE_IDLE:
				playOptional('idle');
				updatePosition_IDLE();
			case STATE_KICKED:
				playOptional('kick');
				updatePosition_KICKED();
			case STATE_ARCING:
				playOptional('fire');
				updatePosition_ARCING();
			case STATE_SHOT:
				cleanup(1000);
				playOptional('shot');
				updatePosition_SHOT();
			case STATE_IMPACTED:
				cleanup(1000);
				playOptional('bounce');
				updatePosition_IMPACTED();
		}		
	}

	var startCleanupTime:Float = null;
	function cleanup(delayMs:Float) {
		if (startCleanupTime == null) {
			startCleanupTime = Conductor.songPosition;
		}
		if (Conductor.songPosition > startCleanupTime + delayMs) {
			kill();
		}
	}

	function getCanProgress() {
		var time:Float = Conductor.songPosition;
		var progress:Float = (time - startingTime) / (endingTime - startingTime);
		return Math.min(progress, 1.0);
	}

	function updatePosition_IDLE() {
		// Start at starting position.
		this.x = initialPosition.x;
		this.y = initialPosition.y;
	}

	function updatePosition_KICKED() {
		// Move up to compensate for larger animation.
		this.x = initialPosition.x;
		this.y = initialPosition.y - 200;
	}

	function updateCanArcPosition() {
		var progress:Float = getCanProgress();

		// Made this a piecewise quadratic function but there's probably a better way.
		// I just futzed around in a graphing calculator until it looked good.
		var yPosition = (progress < 0.8)
			? -3.125 * progress * progress + 5 * progress + 0
			: -12 * progress * progress + 12.1 * progress + 0;

		// X is linear while Y is based on a piecewise curve.
		this.x = arcStartingPosition.x + (arcEndingPosition.x - arcStartingPosition.x) * progress;
		this.y = yPosition * -400 + arcStartingPosition.y;
	}

	function updatePosition_ARCING() {
		// Lerp between start and end position.
		var progress:Float = getCanProgress();
		trace(progress);
		updateCanArcPosition();
	}

	var shotPos:FlxBasePoint = null;

	function updatePosition_SHOT() {
		// Maintain can position.
		// This makes early can shots explode far away and late ones explode closer,
		// for basically no work!
		if (shotPos == null) {
			shotPos = new FlxBasePoint(this.x, this.y);
			var debugIcon:FlxSprite = new FlxSprite(shotPos.x, shotPos.y);
			debugIcon.makeGraphic(8, 8, 0xffff00ff);
			FlxG.state.add(debugIcon);
		}

		this.x = shotPos.x - 325; // Apply animation offset.
		this.y = shotPos.y - 100; // Apply animation offset.
	}

	function updatePosition_IMPACTED() {
		// Maintain can position.
		if (shotPos == null) {
			shotPos = new FlxBasePoint(this.x, this.y);
			var debugIcon:FlxSprite = new FlxSprite(shotPos.x, shotPos.y);
			debugIcon.makeGraphic(8, 8, 0xffff00ff);
			FlxG.state.add(debugIcon);
		}

		// 0,0 is actually very close if not exactly the correct offset.
		this.x = shotPos.x + 0;
		this.y = shotPos.y - 50;
	}
}
