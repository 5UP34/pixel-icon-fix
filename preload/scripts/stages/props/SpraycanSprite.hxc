import flixel.FlxG;
import flixel.FlxSprite;
import flixel.math.FlxBasePoint;
import funkin.Conductor;
import funkin.Paths;
import funkin.play.PlayState;
import funkin.util.BezierUtil;

// We have to use FlxBasePoint in scripts because FlxPoint is inlined and not available in scripts

/**
 * A sprite which represents a spraycan flying through the air that Pico must shoot.
 */
class SpraycanSprite extends FlxSprite
{
	/**
	 * The position of the can when it is in the pile ready to be thrown.
	 */
	public var initialPosition:FlxPoint;

	/**
	 * The position on screen that the spray can should start arcing at.
	 */
	public var arcStartingPosition:FlxPoint;

	/**
	 * The Conductor time at which the spray can should reach the ending position.
	 */
	public var startingTime:Float;

	/**
	 * The position on screen that the spray can should finish arcing at.
	 */
	public var arcEndingPosition:FlxPoint;


	var angularVelFrameByFrame:Float = 0;

	/**
	 * The Conductor time at which the spray can should reach the ending position.
	 */
	public var endingTime:Float;

	public var STATE_IDLE:Int = 0;
	public var STATE_KICKED:Int = 1;
	public var STATE_ARCING:Int = 2;
	public var STATE_SHOT:Int = 3;
	public var STATE_IMPACTED:Int = 4;

	public var currentState:Int = 0;

	var arcControl:FlxSprite = null;

	function new()
	{
		super(0, 0);

		zIndex = 1900;

		frames = Paths.getSparrowAtlas('Spraypaint_Can_Assets');

		// Stationary can
		animation.addByPrefix('idle', 'singular can', 24, true);
		// Can kicked upward, with smear
		animation.addByPrefix('kick', 'can kicked up', 24, true);
		// Can with lit fuse
		animation.addByPrefix('fire', 'can on fire', 24, true);
		// Can bouncing off Pico before exploding
		animation.addByPrefix('bounce', 'can bounce off head', 24, false);
		// Can that has been shot
		animation.addByPrefix('shot', 'can shot bend', 24, false);

		updateHitbox();

		arcControl = new FlxSprite(0, 0);
		arcControl.frames = Paths.getSparrowAtlas('SpraycanArc');
		arcControl.animation.addByPrefix('primary', 'Can Kick Arc 10', 24, true);
		arcControl.animation.addByPrefix('high', 'Can Kick Arc high0', 24, true);
		arcControl.animation.addByPrefix('low', 'Can Kick Arc Shallow0', 24, true);

		// We play the animation to get data from it,
		// like the height of the curve and position at each frame.
		// It needs to be IN the scene for the animation to play,
		// but we don't want it to be visible.
		arcControl.visible = false;
		// FlxG.state.add(arcControl);
	}

	function getArcControlFrame(animationName:String, percent:Float):FlxBasePoint
	{
		var animation = arcControl.animation.getByName(animationName);

		// Interpolate between the two offsets
		// For example, if we are 3.4 frames in, we want to return a value
		// 40% of the way between the third and fourth frame.

		var frameFraction = (percent * (animation.frames.length - 1)) % 1.0;

		var prevFramePointer = Math.floor(percent * (animation.frames.length - 1));
		var nextFramePointer = Math.ceil(percent * (animation.frames.length - 1));

		var prevFrameIndex = animation.frames[prevFramePointer];
		var nextFrameIndex = animation.frames[nextFramePointer];

		var prevFrame = arcControl.frames.frames[prevFrameIndex];
		var nextFrame = arcControl.frames.frames[nextFrameIndex];

		var prevOffset = prevFrame.offset;
		var nextOffset = nextFrame.offset;

		var finalOffset = new FlxBasePoint(0, 0);
		finalOffset.x = prevOffset.x + (nextOffset.x - prevOffset.x) * 1;
		finalOffset.y = prevOffset.y + (nextOffset.y - prevOffset.y) * 1;

		return finalOffset;
	}

	function getArcHeight(animationName:String)
	{
		// TODO: This one causes an unhandled exception in Polymod and crashes the game.
		// arcControl.animation.frames.frames[0].sourceSize.x
		// It's wrong but we still need to handle the problem gracefully instead of crashing.
		// TODO: Excluding a semicolon throws an "unexpected token" error and crashes the game.

		var animation = arcControl.animation.getByName(animationName);
		var animFramePointer = animation.frames[1];
		var animFrame = arcControl.frames.frames[animFramePointer];
		var animHeight = animFrame.sourceSize.y;
		return animHeight;
	}

	function setArcProperties(startPos:FlxBasePoint, startTime:Float, endPos:FlxBasePoint, endTime:Float)
	{
		arcStartingPosition = startPos;
		startingTime = startTime;
		arcEndingPosition = endPos;
		endingTime = endTime;

		var xDiff = endPos.x - startPos.x;
	}

	function playOptional(name:String)
	{
		if (animation.curAnim == null || animation.curAnim.name != name)
		{
			animation.play(name);
			updateHitbox();
		}
	}


	var canRotateTmr:Float = 0;
	function update(elapsed:Float)
	{
		super.update(elapsed);

		canRotateTmr += elapsed;


		if (canRotateTmr >= 2/24)
		{
			canRotateTmr = 0;
			this.angle += angularVelFrameByFrame;
		}

		switch (currentState)
		{
			case STATE_IDLE:
				playOptional('idle');
				updatePosition_IDLE();
			case STATE_KICKED:
				playOptional('kick');
				updatePosition_KICKED();
			case STATE_ARCING:
				playOptional('fire');
				updatePosition_ARCING();
			case STATE_SHOT:
				cleanup(1000);
				playOptional('shot');
				updatePosition_SHOT();
			case STATE_IMPACTED:
				cleanup(1000);
				playOptional('bounce');
				updatePosition_IMPACTED();
		}
	}

	var startCleanupTime:Float = null;

	function cleanup(delayMs:Float)
	{
		if (startCleanupTime == null)
		{
			startCleanupTime = Conductor.instance.songPosition;
		}
		if (Conductor.instance.songPosition > startCleanupTime + delayMs)
		{
			kill();
		}
	}

	function getCanProgress()
	{
		var time:Float = Conductor.instance.songPosition;
		var progress:Float = (time - startingTime) / (endingTime - startingTime);
		return Math.min(progress, 1.0);
	}

	function getBoyfriendAngle()
	{
		var boyfriend = PlayState.instance.currentStage.getBoyfriend().getGraphicMidpoint();
		var angleRad = Math.atan2((boyfriend.y - 40) - y, (boyfriend.x - 40) - x);
		var angleDeg = angleRad * 180.0 / Math.PI;

		//angleDeg -= 15;

		return angleDeg;
	}

	function updatePosition_IDLE()
	{
		// Start at starting position.
		this.x = initialPosition.x;
		this.y = initialPosition.y;
		this.angle = 0;
		angularVelFrameByFrame = 0;

		this.visible = false;
	}

	function updatePosition_KICKED()
	{
		// Move up to compensate for larger animation.
		this.x = initialPosition.x;
		this.y = initialPosition.y - 400;
		this.angle = 0;
		angularVelFrameByFrame = 0;

		this.visible = true;
	}

	var arcVariant:String = 'primary';

	function updateCanArcPosition()
	{
		var progress:Float = getCanProgress();

		var arcFrameOffset = getArcControlFrame(arcVariant, progress);

		this.x = arcStartingPosition.x + (arcFrameOffset.x * 1.58);
		this.y = arcStartingPosition.y + arcFrameOffset.y + (200);

		// The arc starting position is at the bottom left,
		// so we need to adjust for the height of the arc.
		// Note the height of the arc is different depending on the variant.
		this.y -= getArcHeight(arcVariant);

		/*
			// Made this a piecewise quadratic function but there's probably a better way.
			// I just futzed around in a graphing calculator until it looked good.
			var yPosition = (progress < 0.8)
				? -3.125 * progress * progress + 5 * progress + 0
				: -12 * progress * progress + 12.1 * progress + 0;

			// X is linear while Y is based on a piecewise curve.
			this.x = arcStartingPosition.x + (arcEndingPosition.x - arcStartingPosition.x) * progress;
			this.y = yPosition * -400 + arcStartingPosition.y;
		 */
	}

	function updatePosition_ARCING()
	{
		// Lerp between start and end position.
		var progress:Float = getCanProgress();
		updateCanArcPosition();

		// this.angle = 0;
		angularVelFrameByFrame = 65; // # degrees per second.
	}

	var shotPos:FlxBasePoint = null;

	function setShotRotationOrigin()
	{
		var anim = this.animation.getByName('shot');
		var animFramePointer = anim.frames[0];
		var animFrame = this.frames.frames[animFramePointer];
		var animWidth = animFrame.sourceSize.x;
		var animHeight = animFrame.sourceSize.y;

		this.origin.x = animWidth / 2;
		this.origin.y = animHeight / 2;
	}

	function updatePosition_SHOT()
	{
		// Maintain can position.
		// This makes early can shots explode far away and late ones explode closer,
		// for basically no work!
		if (shotPos == null)
		{
			shotPos = new FlxBasePoint(this.x, this.y);
			// var debugIcon:FlxSprite = new FlxSprite(shotPos.x, shotPos.y);
			// debugIcon.makeGraphic(8, 8, 0xffff00ff);
			// FlxG.state.add(debugIcon);
			//setShotRotationOrigin();
			//this.angle = getBoyfriendAngle();
		}

		this.angle = -25 + getBoyfriendAngle();

		this.x = shotPos.x - 325; // Apply animation offset.
		this.y = shotPos.y - 100; // Apply animation offset.


		var bf = PlayState.instance.currentStage.getBoyfriend().getGraphicMidpoint();
		var dx = (bf.x - 40) - this.x;
		var dy = (bf.y - 10) - this.y;

		var angle = Math.atan2(dy, dx);

		this.x -= 300 * Math.cos(angle);
		this.y -= 300 * Math.sin(angle);

		// var length = Math.sqrt(dx*dx + dy*dy);
		// dx /= length;
		// dy /= length;

		// dx *= 100;
		// dy *= 100;
		// this.x += dx;
		// this.y += dy;


		angularVelFrameByFrame = 0;
	}

	function updatePosition_IMPACTED()
	{
		// Maintain can position.
		if (shotPos == null)
		{
			shotPos = new FlxBasePoint(this.x, this.y);
		}

		this.x = shotPos.x - 100;
		this.y = shotPos.y - 50;
		this.angle = 0;
		angularVelFrameByFrame = 0;
	}
}
